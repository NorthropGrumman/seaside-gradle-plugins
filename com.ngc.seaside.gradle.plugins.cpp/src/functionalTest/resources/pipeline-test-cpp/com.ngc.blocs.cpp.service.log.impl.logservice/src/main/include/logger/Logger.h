/**
 * UNCLASSIFIED
 *
 * Copyright 2020 Northrop Grumman Systems Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
//------------------------------------------------------------------------------
//  UNCLASSIFIED (U)
//------------------------------------------------------------------------------
#ifndef _BLOCS_Logger_H
#define _BLOCS_Logger_H

//#include "gem/utility/time/TimeSource.h"
#include "logger/LogLevel.h"
#include "logger/LogOutputStrategy.h"
#include <iostream>
#include <vector>

// This should be set in compiler flag
#define __ALL_LOGGER_LOGGING //this is the default

#ifdef __NO_DEBUG_LOGGING //ALL LOGGER CLASS DIRECTED LOGGING ENABLED EXCEPT DEBUG and FINE
#define LOG_FINE_POSSIBLE false
#define LOG_DEBUG_POSSIBLE false
#define LOG_INFO_POSSIBLE true
#define LOG_WARN_POSSIBLE true
#define LOG_USERGRAM_POSSIBLE true
#define LOG_ERROR_POSSIBLE true
#define LOG_FATAL_POSSIBLE true
#define LOG_RAW_POSSIBLE true
#undef __ALL_LOGGER_LOGGING
#endif

#ifdef __ALL_LOGGER_LOGGING //ALL LOGGER CLASS DIRECTED LOGGING ENABLED
#define LOG_FINE_POSSIBLE true
#define LOG_DEBUG_POSSIBLE true
#define LOG_INFO_POSSIBLE true
#define LOG_WARN_POSSIBLE true
#define LOG_USERGRAM_POSSIBLE true
#define LOG_ERROR_POSSIBLE true
#define LOG_FATAL_POSSIBLE true
#define LOG_RAW_POSSIBLE true
#endif


//This is set when verbose stdout debug logging is desired in low level utility files
//(files that would never enable logging except for development debug/verification
// of a thin, self contained class).  Debug code in this files are generally
// std::cout calls bracked by an ifdef.  THIS SHOULD BE USED SPARINGLY.
//#ifdef __MAX_LOGGING
//std::cout.setf("MAX LOGGING IS ENABLED");
//#endif

namespace blocs { namespace basiclogservice {

      static std::string NULL_LOGGER_NAME = "NULL_LOGGER";

      /*! \brief Logger is a thin logging interface for writing text based log messages to a logging
      destination referred to as a LogOutputStrategy.

      Logger is a thin logging interface for writing text based log messages out to a logging
      destination referred to as a LogOutputStrategy.  Once the Logger is created, log messages are
      output by a using application by invoking one of the following Logger defined <B>macros</B>:
      */

      class Logger {

         public :

            /*!
            Creates a Logger with the input loggerName and optional relativeTimeSource pointer.  If a Logger
            already exists with loggerName, that Logger is shutdown and replaced with the newly created
            Logger.  This Logger will have no LogOutputStrategy so it will not produce any output unless
            strategies are added by calling addStrategy.
            <P>
            Formatted log messages generated by this Logger will include current time referece obtained from
            the optional input relative TimeSource pointer.  An example of a relativeTimeSource is simulation time.
            Ownership of the relative TimeSource remains with the client.
            <P>
            Example Call:
            <PRE>
            Logger &logger = Logger::createLogger("myloggername");
            </PRE>
            <P>
            Note that Loggers are initially created with their logging level set to NONE unless
            the logging level was pre-initialized through a setLoggingLevel call.
            */
            static Logger & createLogger( const std::string & loggerName);
			  /*,TimeSource * relativeTimeSource = NULL);*/

            /*!
            Creates a Logger with the input loggerName, strategy pointer, and optional relativeTimeSource pointer.
            If a Logger already exists with loggerName, that Logger is shutdown and replaced with the newly
            created Logger.
            <P>
            This Logger will output log messages to the LogOutputStrategy referenced by the input pointer.
            The produced <I>Logger will take ownership</I> of the referenced LogOutputStrategy and release it
            upon shutdown of the Logger.  Therefore, clients should not call <B>delete</B> on LogOutputStrategy.
            <P>
            Formatted log messages generated by this Logger will include current time referece obtained from
            the optional input relative TimeSource pointer.  An example of a relativeTimeSource is simulation time.
            Ownership of the relative TimeSource remains with the client.
            <P>
            Example Call:
            <PRE>
            Logger &logger = Logger::createLogger("myloggername", (new OstreamOutputStrategy()));
            </PRE>
            <P>
            Note that Loggers are initially created with their logging level set to NONE unless
            the logging level was pre-initialized through a setLoggingLevel call.
            */
            static Logger & createLogger( const std::string & loggerName,
                                          LogOutputStrategy * strategy);
            							  /*,TimeSource * relativeTimeSource = NULL);*/

            /*!
            Creates a Logger with the input loggerName, strategy vector, and optional relativeTimeSource pointer.
            If a Logger already exists with loggerName, that Logger is shutdown and replaced with the newly
            created Logger.
            <P>
            This Logger will output log messages to all strategies reference by the LogOutputStrategyPtrVector.
            The produced <I>Logger will take ownership</I> of all the LogOutputStrategy objects referenced
            by the LogOutputStrategyPtrVector and release them upon shutdown of the Logger.
            Therefore, clients should not call <B>delete</B> on any LogOutputStrategy objects referenced
            by the LogOutputStrategyPtrVector.
            <P>
            Formatted log messages generated by this Logger will include current time referece obtained from
            the optional input relative TimeSource pointer.  An example of a relativeTimeSource is simulation time.
            Ownership of the relative TimeSource remains with the client.
            <P>
            Example Call:
            <PRE>
            LogOutputStrategyPtrVector strategies;
            strategies.push_back(new OstreamOutputStrategy());
            strategies.push_back(new TextFileOutputStrategy("myloggername.txt"));

            Logger &logger = Logger::createLogger("myloggername", strategies);
            </PRE>
            <P>
            Note that Loggers are initially created with their logging level set to NONE unless
            the logging level was pre-initialized through a setLoggingLevel call.
            */
            static Logger & createLogger( const std::string & loggerName,
                                          const LogOutputStrategyPtrVector & strategies);
                                          /*,TimeSource * relativeTimeSource = NULL);*/

            /*!
            Obtains the Logger instance identified by the input loggerName
            */

            static Logger & get(const std::string & loggerName);

            /*!
            Sets the single logging level threshold of the Logger identified by the input
            loggerName to the input loggingLevel value.  A Logger will log messages at the
            level it has been set to or higher.
            <P>
            A Logger's logging level can be pre-set through this method method
            before the Logger identified by the input name is created.
            */
            static void setLoggingLevel(const std::string & loggerName, LogLevel::Values loggingLevel);

            /*!
            Shuts down and destroys (deletes) the Logger identified by the input
            loggerName.  Any external reference to the logger becomes invalid.
            */
            static void shutdownAndDeleteLogger(const std::string & loggerName);

            /*!
            Add the LogOutputStrategy reference by the input pointer to this Logger as (another)
            destination for it to output log messages to.
            The <I>Logger will take ownership</I> of the referenced LogOutputStrategy and release it
            upon shutdown of the Logger.  Therefore, clients should not call <B>delete</B> on LogOutputStrategy.
            */
            void addStrategy(LogOutputStrategy * strategy);

            /*!
            Sets the single logging level threshold of this Logger to the input loggingLevel value.
            A Logger will log messages at the level it has been set to or higher.
            */
            void setLoggingLevel(LogLevel::Values level);

            /*!
            Sets the relative TimeSource (such as a simulation time) for the logger.
            The current time of the relative time source is included in the formatted log messages
            generated by this Logger.  Ownership of the relative TimeSource object remains
            with the client.  It should not be deleted, however, as long as this logger
            has not been shutdown unless a call is made to the Logger to set the relative
            time source to NULL.
            */
            //void setRelativeTimeSource(TimeSource * timeSource);

            /*!
            Obtains the logging level associated with this Logger.
            */
            LogLevel::Values getLoggingLevel() const;

            /*!
            Obtains the name of this Logger.
            */
            std::string & getName();

            bool willLogMessageAtLevel(LogLevel::Values minimumLevel) const;

            /*!
             This is the main logging method for writing output formatted lines of logger text.
             <B>Normally, a call to this method would never directly appear in client code</B>.
             Instead, clients invoke this method indirectly by calling one of the
             logXXXX(logger, text) macros.
             <P>
             In a purely logical sense, this method is "private".  However, since this method is directly
             invoked from macro code substitution, it must be public in order to be accessible
             through the logXXXX macros.
             */
            void logFormattedText(
               const LogLevel::Values & level,
               const std::string & text,
               const std::string & sourceLocation);

            /*!
            This is the main logging method for writing output raw, unformatted (at least by the Logger)
            text to the Logger.  Unlike all the other "log" methods, this method does not write "lines" of
            text to the file (i.e. it will not add end of line character(s) to the text).  Clients wishing to
            use this method to output lines must ensure the input text field already contains any end of line
            characters.

            It is acceptable to invoke this directly or through
            the logRaw macro, although the latter will be less efficient if you already have
            a handle to the Logger object.
            */
            void logRawText(const std::string & text);

            /*!
            This is a support logging method that accepts a pre-formatted log output data structure
            and logs it to this Logger.  Generally, this method would only be used by a chain or
            rollup logger scheme implemented through a custom LogOutputStrategy.
            */
            void logLogOutputData(const LogOutputData & logOutputData);

         private :

            //The TimeSource for the local system clock
            //TimeSource systemTimeSource;

            //Internal setup method for registering the Logger in the static internal lists
            static void registerLogger(Logger * logger);

            //Strips path information off a fully qualified pathname returning a string of just the filename.
            static std::string getFileFromCanonicalName(const std::string & canonicalFile);

            //Private Logger constructor invoked by the varios createLogger methods
            Logger (const std::string & loggerName/*, TimeSource * relativeTimeSource = NULL*/);
            virtual ~Logger(void);

            Logger(const Logger& rhs);  // implicit copyability does not make sense
            Logger &operator=(const Logger & rhs); // implicit copyability does not make sense


            ///////// PRIVATE MEMBER VARIABLES ///////////

            //The unique identifier of this Logger
            std::string loggerName;

            std::size_t loggerId;

            //The LogLevel of this Logger
            LogLevel::Values loggerLevel;

            //The strategies this Logger will output to.
            LogOutputStrategyPtrVector strategies;

            //The relative (simulation) time source.
            //TimeSource * relativeTimeSource;
      };

}} //NAMESPACE

#endif

