/*
 * UNCLASSIFIED
 *
 * Copyright 2020 Northrop Grumman Systems Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
buildscript {
   ext {
      bootstrapDirectory = "${project.buildDir}/bootstrapping"
      releaseInProgress = project.hasProperty('bootstrapRelease')

      getSelfDependencies = { ->
         // Put all files on in the bootstrapDirectory on the build classpath.
         // Don't use project.file since we want to configure the error message if the file is not found.
         def dir = new File("$bootstrapDirectory")
         if (!dir.isDirectory() || dir.list().length == 0) {
            throw new IllegalStateException(
                  "Cannot perform a release because project has not already been built, please run 'gradle prepareForRelease' first!")
         }

         project.file("$bootstrapDirectory")
               .list()
               .toList()
         // Remove .jar extension.
               .collect { it.substring(0, it.length() - 4) } // 4 = '.jar'.length()
      }
   }

   repositories {
      mavenCentral()
      mavenLocal()

      maven {
         url "https://plugins.gradle.org/m2/"
      }

      // Allows the build to reference its own artifact from a previous build.
      flatDir {
         dirs "${bootstrapDirectory}"
      }
   }

   dependencies {
      classpath 'com.github.ksoichiro:gradle-console-reporter:0.5.0'
      classpath 'gradle.plugin.nl.javadude.gradle.plugins:license-gradle-plugin:0.14.0'
      if (releaseInProgress) {
         getSelfDependencies().each { name ->
            classpath name: "$name"
         }
      }
   }
}

def nonPluginProjects = [project(':gradle.plugins'), project(':gradle.plugins.testutils'),
                         project(':gradle.plugins.base')]

apply plugin: 'base'
if (releaseInProgress) {
   apply plugin: 'com.ngc.seaside.release.root'
   apply plugin: 'com.ngc.seaside.root.parent'

   license {
      header = file('LICENSE')
      ext.year = Calendar.getInstance().get(Calendar.YEAR)
   }
}

/**
 * Project level build for the seaside-gradle-parent gradle plugin.
 */
subprojects {
   ext {
      isPlugin = !(project in nonPluginProjects)
   }

   apply plugin: 'java-library'
   apply plugin: 'groovy'
   apply plugin: 'maven-publish'
   apply plugin: 'com.github.hierynomus.license'
   if (isPlugin) {
      apply plugin: 'java-gradle-plugin'
   }

   group = 'com.ngc.seaside'
   version = '2.23.0-SNAPSHOT'

   // Required in order to use implementation and api dependencies with groovy
   configurations {
      apiElements {
         outgoing.variants.getByName('classes').artifact(
               file: compileGroovy.destinationDir,
               type: ArtifactTypeDefinition.JVM_CLASS_DIRECTORY,
               builtBy: compileGroovy)
      }
   }

   plugins.withId('java') {
      sourceCompatibility = '1.8'
      targetCompatibility = '1.8'
      tasks.withType(Jar) {
         from file('LICENSE')
      }
   }

   plugins.withId('com.github.hierynomus.license') {
      license {
         header = file('LICENSE')
         ext.year = Calendar.getInstance().get(Calendar.YEAR)
      }
   }

   ext {
      jaxbVersion = '2.3.0.1'
      junitVersion = '4.12'
      aQuteVersion = '4.0.0'
      commonsLang3Version = '3.5'
      commonsIOVersion = '2.5'
      unbescapeVersion = '1.1.3.RELEASE'
      mockitoVersion = '2.19.0'
      blocsVersion = '2.1.1'
      sonarQubeVersion = '2.5'
      dependencyUpdatesVersion = '0.15.0'
      consoleReporterVersion = '0.5.0'
      guavaVersion = '22.0'
      aetherVersion = '1.1.0'
      mavenVersion = '3.5.2'
      licensePluginVersion = '0.14.0'
   }

   repositories {
      mavenCentral()
      mavenLocal()

      maven {
         url "https://plugins.gradle.org/m2/"
      }
   }

   //Augment the name of the jar to prepend the group.
   jar {
      archiveName = "${project.group}.${project.name}-${project.version}.jar"
   }

   // Enable the creation of sources JAR which is used when uploading to Nexus.
   task sourcesJar(type: Jar, dependsOn: classes) {
      classifier = 'sources'
      from sourceSets.main.allSource
      archiveName = "${project.group}.${project.name}-${project.version}-${classifier}.jar"
   }

   // Enable the creation of a Javadoc JAR which is used when uploading to Nexus.
   task javadocJar(type: Jar, dependsOn: javadoc) {
      classifier = 'javadoc'
      from javadoc.destinationDir
      archiveName = "${project.group}.${project.name}-${project.version}-${classifier}.jar"
   }

   // Disable the annoying doclint capability of Java 8 which causes builds to fail if the JavaDocs aren't right.
   if (JavaVersion.current().isJava8Compatible()) {
      allprojects {
         tasks.withType(Javadoc) {
            options.addStringOption('Xdoclint:none', '-quiet')
         }
      }
   }
   if (JavaVersion.current().isJava9Compatible()) {
      allprojects {
         tasks.withType(Javadoc) {
            //options.addBooleanOption('html5', true)
         }
      }
   }

   // Add the additional JAR artifacts, this results in them being included when uploading to Nexus.
   artifacts {
      archives sourcesJar
      archives javadocJar
   }

   publishing {
      // Do no do this if the java-gradle-plugin is applied because it will do this automatically.
      // If this is declared twice, you can get errors during a release because artifacts are being uploaded
      // multiple times.
      if (!isPlugin) {
         publications {
            mavenJava(MavenPublication) {
               from components.java
            }
         }
      }

      repositories {
         maven {
            name = version.endsWith('-SNAPSHOT') ? 'NexusSnapshots' : 'NexusReleases'
            url = version.endsWith('-SNAPSHOT') ? nexusSnapshots : nexusReleases
            credentials {
               username nexusUsername
               password nexusPassword
            }
         }
      }
   }

   sourceSets {
      integrationTest {
         java.srcDir file('src/integrationTest/java')
         groovy.srcDir file('src/integrationTest/groovy')
         resources.srcDir file('src/integrationTest/resources')
      }

      functionalTest {
         java.srcDir file('src/functionalTest/java')
         groovy.srcDir file('src/functionalTest/groovy')
         resources.srcDir file('src/functionalTest/resources')
      }
   }

   configurations {
      integrationTestCompile.extendsFrom testCompile
      integrationTestImplementation.extendsFrom testImplementation
      integrationTestRuntime.extendsFrom testRuntime
      functionalTestCompile.extendsFrom testCompile
      functionalTestImplementation.extendsFrom testImplementation
      functionalTestRuntime.extendsFrom testRuntime
      if (isPlugin) {
         // Allows functional tests to apply plugins from other projects
         testRuntimeClasspath.allDependencies.withType(ProjectDependency).all {
            dependencyProject.sourceSets {
               main {
                  gradlePlugin.pluginSourceSet.runtimeClasspath += compileClasspath + output
               }
            }
         }
      }
   }

   dependencies {
      integrationTestCompile sourceSets.main.output
      functionalTestCompile sourceSets.main.output
   }

   tasks.getByName("test").group = "test"

   task integrationTest(type: Test, group: "test") {
      testClassesDirs = sourceSets.integrationTest.output
      classpath = sourceSets.integrationTest.runtimeClasspath
   }

   task functionalTest(type: Test, group: "test") {
      testClassesDirs = sourceSets.functionalTest.output
      classpath = sourceSets.functionalTest.runtimeClasspath
   }

   integrationTest.shouldRunAfter(test)
   functionalTest.shouldRunAfter(integrationTest)
   check.dependsOn(integrationTest, functionalTest)

   // tasks.withType(Test).all { testTask ->
   //    testTask.systemProperty 'nexusConsolidated', nexusConsolidated
   //    def systemProperties = ['javax.net.ssl.trustStore', 'http.proxyHost', 'http.proxyPort', 'http.nonProxyHosts',
   //                            'https.proxyHost', 'https.proxyPort', 'https.nonProxyHosts', 'sonar.host.url']
   //    for (String key : systemProperties) {
   //       String value = System.properties[key]
   //       if (value != null) {
   //          testTask.systemProperty(key, value)
   //       }
   //    }
   // }

   task copyPlugin(type: Copy) {
      from jar
      into "$bootstrapDirectory"
   }

   task copyDependencies(type: Copy) {
      from configurations.compile
      into "$bootstrapDirectory"
   }

   task prepareForRelease(description: 'Prepares this project for a release.',
                          dependsOn: [copyPlugin, copyDependencies])
}
